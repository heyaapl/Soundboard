name: Package and Release

# TRIGGERS:
# - GitHub Release creation → RELEASE builds and CurseForge uploads
# - Pushes to main → Automatic RELEASE builds with hotfix suffixes (1.3.3a, b, c...)
# - Pushes to feature/develop branches → ALPHA builds

on:
  release:
    types: [published]    # Trigger on manual release creation/publication
  push:
    branches:
      - main              # Automatic hotfix releases (1.3.3a, b, c...)
      - develop
      - 'feature/**'
      - 'hotfix/**' 
      - 'release/**'

env:
  GAME_VERSIONS: "5.5.0,11.2.5,1.15.7,3.4.5,4.4.2,2.5.4"  # MOP Classic and Retail

jobs:
  package:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required to create tags and releases
      actions: read    # Required to read workflow context
    outputs:
      release-type: ${{ steps.release-type.outputs.RELEASE_TYPE }}
      version: ${{ steps.release-type.outputs.VERSION }}
      is-tagged: ${{ steps.release-type.outputs.IS_TAGGED }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for proper versioning
          submodules: recursive
          token: ${{ secrets.GITHUB_TOKEN }}  # Ensure we can push tags
          
      - name: Determine release type and version
        id: release-type
        run: |
          echo "Event: ${{ github.event_name }}"
          echo "Branch/Tag: ${{ github.ref_name }}"
          echo "Ref: ${{ github.ref }}"
          
          # Determine release type based on event type
          if [[ "${{ github.event_name }}" == "release" ]]; then
            # GitHub Release was created - this is always a RELEASE build
            echo "Debug: Processing GitHub Release event"
            RELEASE_TYPE="release"
            
            # Extract version from release tag
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            VERSION="${RELEASE_TAG#v}"  # Remove v prefix if present
            IS_TAGGED="true"           # Release creation already created the tag
            SHOULD_CREATE_TAG="false"  # Tag already exists
            
            echo "Debug: Release event - TAG=${RELEASE_TAG}, VERSION=${VERSION}"
            
            # Determine release vs pre-release
            if [[ "${RELEASE_TAG}" == *"alpha"* ]]; then
              RELEASE_TYPE="alpha"
              echo "Debug: Detected alpha release"
            elif [[ "${RELEASE_TAG}" == *"beta"* ]]; then
              RELEASE_TYPE="beta"
              echo "Debug: Detected beta release"
            else
              RELEASE_TYPE="release"
              echo "Debug: Detected stable release"
            fi
            
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            BRANCH_NAME="${{ github.ref_name }}"
            echo "Debug: Processing push to branch '${BRANCH_NAME}'"
            
            if [[ "${BRANCH_NAME}" == "main" ]]; then
              # Main branch push - automatic release with hotfix suffixes
              echo "Debug: Main branch push - setting up automatic RELEASE build"
              RELEASE_TYPE="release"
              BASE_VERSION=$(grep "## Version:" Soundboard.toc | sed 's/## Version: //' | xargs)
              
              # Check if base version tag already exists, find next available suffix
              echo "🏷️ Checking for existing releases of version ${BASE_VERSION}"
              git fetch --tags origin
              
              BASE_TAG_NAME="v${BASE_VERSION}"
              if git rev-parse --verify "refs/tags/${BASE_TAG_NAME}" >/dev/null 2>&1; then
                echo "⚠️  Base tag ${BASE_TAG_NAME} exists, finding hotfix suffix..."
                
                # Try suffixes a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z
                SUFFIX=""
                for letter in a b c d e f g h i j k l m n o p q r s t u v w x y z; do
                  CANDIDATE_TAG="${BASE_TAG_NAME}${letter}"
                  if ! git rev-parse --verify "refs/tags/${CANDIDATE_TAG}" >/dev/null 2>&1; then
                    SUFFIX="${letter}"
                    VERSION="${BASE_VERSION}${letter}"
                    break
                  fi
                done
                
                if [[ -z "${SUFFIX}" ]]; then
                  echo "❌ Could not find available hotfix suffix after trying a-z"
                  exit 1
                fi
                
                echo "✅ Using hotfix suffix '${SUFFIX}': ${VERSION}"
              else
                echo "✅ Base version ${BASE_VERSION} is available"
                VERSION="${BASE_VERSION}"
              fi
              
              IS_TAGGED="false"
              SHOULD_CREATE_TAG="true"
              echo "Debug: Main branch - RELEASE_TYPE=${RELEASE_TYPE}, VERSION=${VERSION}"
              
            else
              # Feature/develop branches - alpha builds
              RELEASE_TYPE="alpha"
              BASE_VERSION=$(grep "## Version:" Soundboard.toc | sed 's/## Version: //' | xargs)
              VERSION="${BASE_VERSION}-dev-${BRANCH_NAME//\//-}"  # Include branch name for clarity
              IS_TAGGED="false"
              SHOULD_CREATE_TAG="false"
              
              echo "Debug: Feature branch build - RELEASE_TYPE=${RELEASE_TYPE}, VERSION=${VERSION}"
            fi
            
          else
            echo "❌ Unsupported event type: ${{ github.event_name }}"
            exit 1
          fi
          
          echo "RELEASE_TYPE=${RELEASE_TYPE}" >> $GITHUB_OUTPUT
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT  
          echo "IS_TAGGED=${IS_TAGGED}" >> $GITHUB_OUTPUT
          echo "SHOULD_CREATE_TAG=${SHOULD_CREATE_TAG}" >> $GITHUB_OUTPUT
          
          echo "🏷️  Release Type: ${RELEASE_TYPE}"
          echo "📦  Version: ${VERSION}"
          echo "🏷️  Is Tagged: ${IS_TAGGED}"
          echo "🏷️  Should Create Tag: ${SHOULD_CREATE_TAG}"
          
      - name: Create automatic release tag for main branch pushes
        if: steps.release-type.outputs.SHOULD_CREATE_TAG == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.release-type.outputs.VERSION }}"
          TAG_NAME="v${VERSION}"
          
          echo "🏷️ Creating automatic release tag: ${TAG_NAME}"
          echo "📝 Event: ${{ github.event_name }}"
          echo "📝 Branch: ${{ github.ref_name }}"
          
          # Configure git with token authentication
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Set up authenticated remote URL
          git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git"
          
          # Fetch all tags to ensure we have the latest
          git fetch --tags origin
          
          # Verify tag doesn't already exist (it shouldn't since we checked in the previous step)
          if git rev-parse --verify "refs/tags/${TAG_NAME}" >/dev/null 2>&1; then
            echo "❌ Tag ${TAG_NAME} already exists - this should not happen"
            exit 1
          fi
          
          echo "✅ Creating new tag: ${TAG_NAME}"
          echo "⚠️  Using backdated timestamp to prevent 'future tag' detection by packager"
          
          # Create and push the tag with a slight time offset to prevent "future tag" detection
          # Use a timestamp that's 30 seconds in the past to ensure it's not considered "future"
          TIMESTAMP=$(date -u -d '30 seconds ago' '+%Y-%m-%d %H:%M:%S')
          echo "🕒 Creating tag with timestamp: ${TIMESTAMP} UTC"
          
          # Set git environment to use the backdated timestamp
          export GIT_COMMITTER_DATE="${TIMESTAMP}"
          export GIT_AUTHOR_DATE="${TIMESTAMP}"
          
          git tag "${TAG_NAME}" -m "Automatic release tag for ${TAG_NAME}"
          git push origin "${TAG_NAME}"
          
          # Clear the timestamp variables
          unset GIT_COMMITTER_DATE
          unset GIT_AUTHOR_DATE
          
          echo "✅ Created and pushed tag: ${TAG_NAME}"
          echo "📦 Final version for packaging: ${VERSION}"
          
          # Update our outputs to reflect that we're now tagged
          echo "IS_TAGGED=true" >> $GITHUB_OUTPUT
          
          # Extended pause to ensure tag is fully propagated and avoid "future tag" detection
          echo "⏳ Waiting for tag propagation and timestamp validation..."
          sleep 10
          
          # Verify tag was created successfully
          if git rev-parse --verify "refs/tags/${TAG_NAME}" >/dev/null 2>&1; then
            echo "✅ Tag ${TAG_NAME} verified locally"
          else
            echo "❌ Tag ${TAG_NAME} not found locally after creation"
            exit 1
          fi
          
      - name: Refresh git state for packager
        if: steps.release-type.outputs.SHOULD_CREATE_TAG == 'true'
        run: |
          echo "🔄 Refreshing git state to ensure packager sees new tag..."
          git fetch --tags origin
          
          # Additional wait to ensure remote tag is fully propagated
          echo "⏳ Additional propagation delay for remote systems..."
          sleep 5
          
          echo "🏷️ Tags now visible:"
          git tag --points-at HEAD
          echo "🔍 Current commit tagged as:"
          if git describe --tags --exact-match HEAD 2>/dev/null; then
            echo "✅ Tag successfully detected by git describe"
          else
            echo "❌ No exact tag match found - this may cause packaging issues"
            exit 1
          fi
          
          # Show tag creation timestamp to help debug future tag issues
          TAG_NAME="v${{ steps.release-type.outputs.VERSION }}"
          echo "🕒 Tag timestamp information:"
          git log -1 --format="Created: %ai" "${TAG_NAME}" || echo "Could not get tag timestamp"
          
          # Additional verification that should prevent "future tag" issues
          echo "🕒 Current system time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "🕒 Tag object info:"
          git cat-file -p "${TAG_NAME}" | head -5 || echo "Could not read tag object"
          
          # Final verification before proceeding to packaging
          echo "✅ All tag verifications passed - ready for packaging"
          
      - name: Update TOC version for dev builds
        if: steps.release-type.outputs.RELEASE_TYPE == 'alpha' && steps.release-type.outputs.IS_TAGGED == 'false'
        run: |
          # Update version in TOC file for dev builds  
          sed -i "s/## Version: .*/## Version: ${{ steps.release-type.outputs.VERSION }}/" Soundboard.toc
          echo "Updated TOC version to: ${{ steps.release-type.outputs.VERSION }}"
          
      - name: Pre-packaging verification
        run: |
          echo "🔍 Pre-packaging state check:"
          echo "📋 Release Type: ${{ steps.release-type.outputs.RELEASE_TYPE }}"
          echo "📝 Version: ${{ steps.release-type.outputs.VERSION }}"
          echo "🏷️ Is Tagged: ${{ steps.release-type.outputs.IS_TAGGED }}"
          echo "🌿 Branch: ${{ github.ref_name }}"
          echo "🔗 Ref: ${{ github.ref }}"
          echo "📦 Package name will be: Soundboard-v${{ steps.release-type.outputs.VERSION }}"
          echo "🏷️ Current git tags on HEAD:"
          git tag --points-at HEAD || echo "❌ No tags found on HEAD"
          echo "🏷️ Tag detection by git describe:"
          git describe --tags --exact-match HEAD 2>/dev/null && echo "✅ Tag detected" || echo "❌ No exact tag match"
          echo "🔑 CF_API_KEY present: ${{ secrets.CF_API_KEY != '' }}"
          echo ""
          echo "🚀 Launching BigWigsMods packager..."
          
      - name: Package addon
        uses: BigWigsMods/packager@v2
        with:
          args: -g ${{ env.GAME_VERSIONS }} -p 1335953 -n "Soundboard-v${{ steps.release-type.outputs.VERSION }}" -d
        env:
          CF_API_KEY: ${{ secrets.CF_API_KEY }}
          GITHUB_OAUTH: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Debug packaging results
        if: always()
        run: |
          echo "📦 Packaging completed"
          echo "🔑 CF_API_KEY present: ${{ secrets.CF_API_KEY != '' }}"
          echo "🎯 Game versions: ${{ env.GAME_VERSIONS }}"
          echo "🆔 CurseForge Project ID: 1335953"
          echo "📋 Our release type determination: ${{ steps.release-type.outputs.RELEASE_TYPE }}"
          echo "📝 Final version used: ${{ steps.release-type.outputs.VERSION }}"
          echo "🏷️ Is Tagged: ${{ steps.release-type.outputs.IS_TAGGED }}"
          echo "🌿 Branch: ${{ github.ref_name }}"
          echo "🔗 Ref: ${{ github.ref }}"
          echo "🔧 Packager args used: -g ${{ env.GAME_VERSIONS }} -p 1335953 -n Soundboard-v${{ steps.release-type.outputs.VERSION }} -d"
          echo "🏷️ Git tags on current commit:"
          git tag --points-at HEAD || echo "No tags found"
          echo "🏷️ Recent git tags for this version family:"
          CURRENT_VERSION="${{ steps.release-type.outputs.VERSION }}"
          BASE_VERSION=$(echo "${CURRENT_VERSION}" | sed 's/[a-z]*$//')
          git tag --sort=-version:refname | grep -E "^v?${BASE_VERSION}[a-z]*$" | head -5 || echo "No matching tags found"
          echo ""
          echo "ℹ️  Release Process:"
          echo "   - Create GitHub Release → Automatic CurseForge upload"
          echo "   - Commits to main → Automatic releases with hotfix suffixes (1.3.3a, b, c...)"
          echo "   - Commits to feature branches → Alpha builds"
          echo ""
          echo "🔗 Check uploads at: https://www.curseforge.com/wow/addons/soundboard-for-wow/files"
          echo "📁 Working directory contents:"
          ls -la || dir
          echo "📁 Looking for .zip files:"
          find . -name "*.zip" 2>/dev/null || echo "No zip files found"
          
      - name: Extract changelog for current version
        id: changelog
        if: steps.release-type.outputs.RELEASE_TYPE == 'release' && github.event_name != 'release'
        run: |
          # Extract the changelog content for the current version
          VERSION="${{ steps.release-type.outputs.VERSION }}"
          
          # Read changelog and extract content for the current version
          awk -v version="$VERSION" '
          BEGIN { 
            found = 0; 
            content = ""; 
            in_version = 0;
          }
          /^## Version / { 
            if (found && in_version) {
              # We hit the next version, stop processing
              exit;
            }
            if ($0 ~ version || gsub(/^## Version /, "") == version) {
              found = 1; 
              in_version = 1;
              next; # Skip the version header itself
            }
          }
          found && in_version { 
            if (content != "") content = content "\n";
            content = content $0;
          }
          END { 
            if (content != "") {
              print content;
            } else {
              print "No changelog content found for version " version;
            }
          }
          ' CHANGELOG.txt > changelog_content.txt
          
          # Store the changelog content in output
          {
            echo 'CHANGELOG_CONTENT<<EOF'
            cat changelog_content.txt
            echo 'EOF'
          } >> $GITHUB_OUTPUT
          
          echo "📝 Extracted changelog for version $VERSION"
          echo "Preview:"
          head -10 changelog_content.txt
          
      - name: Extract release description for release events
        id: release-description
        if: github.event_name == 'release'
        run: |
          # For release events, use the release body as changelog content
          echo "📝 Using GitHub Release description as changelog content"
          {
            echo 'CHANGELOG_CONTENT<<EOF'
            echo "${{ github.event.release.body }}"
            echo 'EOF'
          } >> $GITHUB_OUTPUT
          
      - name: Create GitHub Release (not needed for release events)
        if: steps.release-type.outputs.RELEASE_TYPE == 'release' && github.event_name != 'release'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.release-type.outputs.VERSION }}
          name: Soundboard v${{ steps.release-type.outputs.VERSION }}
          body: |
            ## Soundboard v${{ steps.release-type.outputs.VERSION }}
            
            ${{ steps.changelog.outputs.CHANGELOG_CONTENT || steps.release-description.outputs.CHANGELOG_CONTENT }}
            
            ---
            
            ### 📦 Installation
            1. Download the latest release
            2. Extract to your WoW AddOns folder  
            3. Restart World of Warcraft
            
            ### 🎮 Supported Versions
            - **Mists of Pandaria Classic** (5.5.0) 
            - **World of Warcraft Retail** (11.2.5+)
            
            ### 📥 Download
            Available on [CurseForge](https://www.curseforge.com/wow/addons/soundboard-for-wow)
            
            ### 📋 Full Changelog
            See [CHANGELOG.txt](https://github.com/${{ github.repository }}/blob/v${{ steps.release-type.outputs.VERSION }}/CHANGELOG.txt) for complete version history.
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Send Discord Notification
        if: github.event_name == 'release' || (github.event_name == 'push' && github.ref_name == 'main')
        run: |
          # Extract changelog summary for Discord
          VERSION="${{ steps.release-type.outputs.VERSION }}"
          
          # Create a concise, Discord-friendly changelog summary
          if [[ "$VERSION" == "1.3.2" ]]; then
            CHANGELOG_SUMMARY="**NEW COMEDY GOLD** - Massive collection of The Office, Monty Python, and internet meme classics!"
            CHANGELOG_SUMMARY+="\n\n**📺 The Office Pack** - 6 new sounds including Identity Theft, That's What She Said, and Office Theme"
            CHANGELOG_SUMMARY+="\n**🏰 Monty Python Pack** - 6 new sounds from Holy Grail and Life of Brian"  
            CHANGELOG_SUMMARY+="\n**🎭 Meme Collection** - 6 new internet classics and viral hits"
            CHANGELOG_SUMMARY+="\n\n**Total: 18 new sounds** across 3 categories!"
          else
            # For release events, extract summary from GitHub release or fallback to changelog
            if [[ "${{ github.event_name }}" == "release" ]]; then
              # Use the first line of the release description
              CHANGELOG_SUMMARY=$(echo "${{ github.event.release.body }}" | head -1 | sed 's/^[*#]*//' | sed 's/^\s*//')
              if [[ -z "$CHANGELOG_SUMMARY" ]]; then
                CHANGELOG_SUMMARY="New version released via GitHub Release!"
              fi
            else
              # Extract the main description line for other versions
              CHANGELOG_SUMMARY=$(awk -v version="$VERSION" '
              /^## Version / { 
                if ($0 ~ version) {
                  found = 1; 
                  getline;
                  if ($0 ~ /^\*\*.*\*\*/) {
                    gsub(/^\*\*/, "", $0);
                    gsub(/\*\*.*$/, "", $0);
                    print $0;
                    exit;
                  }
                }
              }
              END { 
                if (!found) print "New version released with improvements and fixes!";
              }
              ' CHANGELOG.txt)
            fi
          fi
          
          # Get current date and create JSON payload
          CURRENT_DATE=$(date -u '+%B %d, %Y')
          CURRENT_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%S.000Z)
          
          echo "🔍 Discord changelog summary:"
          echo -e "$CHANGELOG_SUMMARY"
          
          # Create Discord webhook payload using jq to ensure valid JSON
          jq -n \
            --arg title "🎵 Soundboard - New Release Available!" \
            --arg description "A new version of Soundboard has been released!" \
            --arg version "v$VERSION" \
            --arg date "$CURRENT_DATE" \
            --arg changelog "$CHANGELOG_SUMMARY" \
            --arg timestamp "$CURRENT_TIMESTAMP" \
            '{
              "embeds": [{
                "title": $title,
                "description": $description,
                "color": 5814783,
                "fields": [
                  {
                    "name": "📦 Version",
                    "value": $version,
                    "inline": true
                  },
                  {
                    "name": "📅 Release Date",
                    "value": $date,
                    "inline": true
                  },
                  {
                    "name": "📈 Downloads",
                    "value": "[CurseForge Page](https://www.curseforge.com/wow/addons/soundboard-for-wow)",
                    "inline": true
                  },
                  {
                    "name": "📋 Changelog Summary",
                    "value": $changelog,
                    "inline": false
                  }
                ],
                "footer": {
                  "text": "Soundboard for World of Warcraft",
                  "icon_url": "https://media.forgecdn.net/avatars/thumbnails/644/825/64/64/638204664364552055.png"
                },
                "timestamp": $timestamp
              }]
            }' > discord_payload.json
          
          echo "📋 Discord payload created:"
          head -10 discord_payload.json
          
          # Send to Discord webhook
          echo "🚀 Sending Discord notification..."
          DISCORD_RESPONSE=$(curl -s -w "%{http_code}" -H "Content-Type: application/json" \
               -X POST \
               -d @discord_payload.json \
               "${{ secrets.DISCORD_WEBHOOK }}")
          
          HTTP_CODE=${DISCORD_RESPONSE: -3}
          RESPONSE_BODY=${DISCORD_RESPONSE%???}
          
          if [[ "$HTTP_CODE" -eq 204 ]]; then
            echo "✅ Discord notification sent successfully for version $VERSION"
          else
            echo "❌ Discord webhook failed with HTTP $HTTP_CODE"
            echo "Response: $RESPONSE_BODY"
            # Don't fail the workflow for Discord issues
          fi
          
  build-summary:
    runs-on: ubuntu-latest
    needs: package
    if: always()
    
    steps:
      - name: Build Summary
        run: |
          echo "## 📦 Soundboard Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Branch/Tag:** \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.package.outputs.version || '❓ Unknown' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target Versions:** MOP 5.5.0, Retail 11.2.5+" >> $GITHUB_STEP_SUMMARY
          echo "**CurseForge Project:** 1335953 (soundboard-for-wow)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Explain CurseForge release type
          if [[ "${{ github.event_name }}" == "release" ]]; then
            echo "**CurseForge Release Type:** 🟢 Release" >> $GITHUB_STEP_SUMMARY
            echo "*(Triggered by GitHub Release creation)*" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref_name }}" == "main" ]]; then
            echo "**CurseForge Release Type:** 🟢 Release" >> $GITHUB_STEP_SUMMARY
            echo "*(Automatic hotfix release from main branch)*" >> $GITHUB_STEP_SUMMARY
          else
            echo "**CurseForge Release Type:** 🟡 Alpha (feature branch)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.package.result }}" == "success" ]]; then
            echo "### ✅ Build Status: Success" >> $GITHUB_STEP_SUMMARY
            
            if [[ "${{ github.event_name }}" == "release" || ("${{ github.event_name }}" == "push" && "${{ github.ref_name }}" == "main") ]]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "🚀 **Release build** - Available on [CurseForge](https://www.curseforge.com/wow/addons/soundboard-for-wow)" >> $GITHUB_STEP_SUMMARY
            else
              echo "" >> $GITHUB_STEP_SUMMARY  
              echo "🧪 **Alpha build** - Available on [CurseForge](https://www.curseforge.com/wow/addons/soundboard-for-wow) for testing" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "### ❌ Build Status: Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Check the package job logs for details." >> $GITHUB_STEP_SUMMARY
          fi
